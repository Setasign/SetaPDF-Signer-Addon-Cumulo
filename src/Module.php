<?php

declare(strict_types=1);

/**
 * @copyright Copyright (c) 2022 Setasign GmbH & Co. KG (https://www.setasign.com)
 * @license   http://opensource.org/licenses/mit-license The MIT License
 */

namespace setasign\SetaPDF\Signer\Module\Cumulo;

use InvalidArgumentException;
use SetaPDF_Core_Reader_FilePath;
use SetaPDF_Signer_Asn1_Element as Asn1Element;
use SetaPDF_Signer_Digest as Digest;
use SetaPDF_Signer_Signature_DictionaryInterface as DictionaryInterface;
use SetaPDF_Signer_Signature_DocumentInterface as DocumentInterface;
use SetaPDF_Signer_Signature_Module_ModuleInterface as ModuleInterface;
use SetaPDF_Signer_Signature_Module_PadesProxyTrait as PadesProxyTrait;

class Module implements ModuleInterface, DictionaryInterface, DocumentInterface
{
    use PadesProxyTrait;

    /**
     * @var Client
     */
    protected $client;

    /**
     * @var string
     */
    protected $certificateId;

    /**
     * A Time based One Time Pin (TOTP) generated by a compatible app such as Google Authenticator, Microsoft
     * Authenticator etc.
     *
     * @var null|string
     */
    protected $otp;

    /**
     * The Signing Activation Data (SAD) token obtained in an earlier authorise request.
     *
     * @see Client::authorize()
     * @var null|string
     */
    protected $sad;

    /**
     * @var string
     */
    protected $signingAlgorithm = 'RS512';

    public function __construct(
        Client $client
    ) {
        $this->client = $client;
    }

    public function setCertificateId(string $certificateId)
    {
        $this->certificateId = $certificateId;
    }

    public function setSigningAlgorithm(string $algorithm)
    {
        switch ($algorithm) {
            case 'RS256':
            case 'ES256':
                $hashingAlgorithm = Digest::SHA_256;
                break;
            case 'RS384':
            case 'ES384':
                $hashingAlgorithm = Digest::SHA_384;
                break;
            case 'RS512':
            case 'ES512':
                $hashingAlgorithm = Digest::SHA_512;
                break;
            default:
                throw new InvalidArgumentException('Invalid signing algorithm!');
        }
        $this->signingAlgorithm = $algorithm;
        $this->_getPadesModule()->setDigest($hashingAlgorithm);
    }

    /**
     * Set a Time based One Time Pin (TOTP) generated by a compatible app such as Google Authenticator, Microsoft
     * Authenticator etc.
     *
     * @param string $otp
     * @return void
     */
    public function setOtp(string $otp): void
    {
        $this->otp = $otp;
    }

    /**
     * Set a Signing Activation Data (SAD) token obtained in an earlier authorise request.
     *
     * @see Client::authorize()
     * @param string $sad
     * @return void
     */
    public function setSad(string $sad): void
    {
        $this->sad = $sad;
    }

    public function getCertificate()
    {
        $padesModule = $this->_getPadesModule();
        if ($padesModule->getCertificate() === null) {
            $certificate = $this->client->getCertificatePEM($this->certificateId);
            $padesModule->setCertificate($certificate);
        }
        return $padesModule->getCertificate();
    }

    public function createSignature(SetaPDF_Core_Reader_FilePath $tmpPath)
    {
        // ensure certificate
        $certificate = $this->getCertificate();
        if ($certificate === null) {
            throw new \BadMethodCallException('Missing certificate!');
        }

        $padesModule = $this->_getPadesModule();
        // get the hash data from the module
        $padesDigest = $padesModule->getDigest();

        $hashData = hash($padesDigest, $padesModule->getDataToSign($tmpPath), true);

        if ($this->sad !== null && $this->otp !== null) {
            throw new \BadMethodCallException('SAD and OTP given! You must only use one.');
        }

        if ($this->sad !== null) {
            // Sign using SAD
            $signatureValue = $this->client->signWithSad(
                $this->certificateId,
                $this->signingAlgorithm,
                $hashData,
                $this->sad
            );
        } elseif ($this->otp !== null) {
            // Sign using OTP
            $signatureValue = $this->client->signWithOtp(
                $this->certificateId,
                $this->signingAlgorithm,
                $hashData,
                $this->otp
            );
        } else {
            throw new \BadMethodCallException('Missing SAD/OTP! Please use setOtp() OR setSad() before.');
        }

        if (\in_array($this->signingAlgorithm, ['ES256', 'ES384', 'ES512'], true)) {
            // THIS NEEDS TO BE USED TO FIX EC SIGNATURES
            $len = strlen($signatureValue);

            $s = substr($signatureValue, 0, $len / 2);
            if (ord($s[0]) & 0x80) { // ensure positive integers
                $s = "\0" . $s;
            }
            $r = substr($signatureValue, $len / 2);
            if (ord($r[0]) & 0x80) { // ensure positive integers
                $r = "\0" . $r;
            }

            $signatureValue = new Asn1Element(
                Asn1Element::SEQUENCE | Asn1Element::IS_CONSTRUCTED,
                '',
                [
                    new Asn1Element(Asn1Element::INTEGER, $s),
                    new Asn1Element(Asn1Element::INTEGER, $r),
                ]
            );
        }

        // pass it to the module
        $padesModule->setSignatureValue($signatureValue);

        return (string) $padesModule->getCms();
    }
}
